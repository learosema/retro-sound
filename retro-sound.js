function u(n,t,e,i){let r=n.createBiquadFilter();return r.type=t,r.frequency.value=e,typeof i<"u"&&(r.Q.value=i),r}function c(n){return 440*Math.pow(2,(f(n)-69)/12)}function f(n){let t=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"],e=parseInt(n.slice(-1)),i=n.slice(0,-1);return(e+1)*12+t.indexOf(i)}function m(n,t="square"){let e={osc:n.createOscillator(),gain:n.createGain()};return e.osc.type=t,e.osc.start(),e.osc.connect(e.gain),e}var h=class{constructor(t,e="square"){this.audioContext=t;this.destination=null;this.filter=null;this.time=0;this.modulator=null;this.modulators=[];this.audioContext=t,this.carrier=m(this.audioContext,e),this.output=this.carrier.gain}withFilter(t,e,i){return this.filter=u(this.audioContext,t,e,i),this.carrier.gain.connect(this.filter),this.output=this.filter,this}withModulator(t="square",e,i,r="frequency"){let s=m(this.audioContext,t);s.osc.frequency.value=e,s.gain.gain.value=i;let a=null;if(!a)switch(r){case"frequency":a=this.carrier.osc.frequency;break;case"gain":a=this.carrier.gain.gain;break;case"filter":a=this.filter?.frequency;break;case"detune":a=this.carrier.osc.detune;break;case"last":this.modulators.length>0&&(a=this.modulators.slice(-1).pop().osc.frequency)}return a&&s.gain.connect(a),this.modulators.push(s),this}toDestination(t=null){return this.destination=t||this.audioContext.destination,this.output.connect(this.destination),this}play(t,e=1,i=0){let r=this.audioContext.currentTime+i,s=c(t);return this.carrier.osc.frequency.setValueAtTime(s,r),this.carrier.gain.gain.setValueAtTime(e,r),this.time=Math.max(i,this.time),this}rampToVolumeAtTime(t,e){let i=this.audioContext.currentTime+e;return this.carrier.gain.gain.linearRampToValueAtTime(t,i),this.time=Math.max(e,this.time),this}expRampToVolumeAtTime(t,e){let i=this.audioContext.currentTime+e;return this.carrier.gain.gain.exponentialRampToValueAtTime(t,i),this.time=Math.max(e,this.time),this}rampToNoteAtTime(t,e){let i=this.audioContext.currentTime+e,r=c(t);return this.carrier.osc.frequency.exponentialRampToValueAtTime(r,i),this.time=Math.max(e,this.time),this}setToNoteAtTime(t,e){let i=this.audioContext.currentTime+e,r=c(t);return this.carrier.osc.frequency.setValueAtTime(r,i),this.time=Math.max(e,this.time),this}setVolumeAtTime(t,e){let i=this.audioContext.currentTime+e;return this.carrier.gain.gain.setValueAtTime(t,i),this.time=Math.max(e,this.time),this}rampFilterFreqAtTime(t,e=0){this.time=Math.max(e,this.time);let i=this.audioContext.currentTime+e;return this.filter?.frequency.linearRampToValueAtTime(t,e),this}expRampFilterFreqAtTime(t,e=0){this.time=Math.max(e,this.time);let i=this.audioContext.currentTime+e;return this.filter?.frequency.exponentialRampToValueAtTime(t,e),this}wait(){return new Promise(t=>setTimeout(t,this.time*1e3))}dispose(){this.carrier.osc.stop(),this.carrier.osc.disconnect(),this.carrier.gain.disconnect(),this.filter?.disconnect();for(let t of this.modulators)t.osc.stop(),t.osc.disconnect(),t.gain.disconnect();this.modulators=[]}async waitDispose(){await this.wait(),this.dispose()}};var o=class o{constructor(t){this.audioContext=t;this.destination=null;this.filter=null;this.time=0;this.createNoiseBuffer(t),this.bufferSource=t.createBufferSource(),this.bufferSource.buffer=o.noiseBuffer,this.bufferSource.loop=!0,this.gain=t.createGain(),this.bufferSource.connect(this.gain),this.output=this.gain}play(t){return this.bufferSource.start(typeof t<"u"?this.audioContext.currentTime+t:void 0),this}stop(t){return this.bufferSource.stop(typeof t<"u"?this.audioContext.currentTime+t:void 0),this}toDestination(t=null){return this.destination=t||this.audioContext.destination,this.output.connect(this.destination),this}withFilter(t,e,i){return this.filter=u(this.audioContext,t,e,i),this.gain.connect(this.filter),this.output=this.filter,this}setFilterFreqAtTime(t,e=0){this.time=Math.max(e,this.time);let i=this.audioContext.currentTime+e;return this.filter?.frequency.setValueAtTime(t,i),this}rampFilterFreqAtTime(t,e=0){this.time=Math.max(e,this.time);let i=this.audioContext.currentTime+e;return this.filter?.frequency.linearRampToValueAtTime(t,i),this}expRampFilterFreqAtTime(t,e=0){this.time=Math.max(e,this.time);let i=this.audioContext.currentTime+e;return this.filter?.frequency.exponentialRampToValueAtTime(t,i),this}rampToVolumeAtTime(t,e){let i=this.audioContext.currentTime+e;return this.gain.gain.linearRampToValueAtTime(t,i),this.time=Math.max(e,this.time),this}expRampToVolumeAtTime(t,e){let i=this.audioContext.currentTime+e;return this.gain.gain.exponentialRampToValueAtTime(t,i),this.time=Math.max(e,this.time),this}setVolumeAtTime(t,e){let i=this.audioContext.currentTime+e;return this.gain.gain.setValueAtTime(t,i),this.time=Math.max(e,this.time),this}createNoiseBuffer(t){if(o.noiseBuffer||o.bufferSize>0)return;let e=2*t.sampleRate,i=t.createBuffer(1,e,t.sampleRate),r=i.getChannelData(0);for(let s=0;s<e;s++)r[s]=Math.random()*2-1;o.bufferSize=e,o.noiseBuffer=i}wait(){return new Promise(t=>setTimeout(t,this.time*1e3))}dispose(){this.gain.disconnect(),this.bufferSource.stop(),this.filter?.disconnect()}async waitDispose(){await this.wait(),this.dispose()}};o.bufferSize=0,o.noiseBuffer=null;var l=o;export{h as Sound,l as WhiteNoise,u as createFilter,c as noteToFrequency,f as noteToMIDI};
