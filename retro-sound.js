function u(n,e,t,i){let r=n.createBiquadFilter();return r.type=e,r.frequency.value=t,typeof i<"u"&&(r.Q.value=i),r}function c(n){return 440*Math.pow(2,(f(n)-69)/12)}function f(n){let e=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"],t=parseInt(n.slice(-1)),i=n.slice(0,-1);return(t+1)*12+e.indexOf(i)}function m(n,e="square"){let t={osc:n.createOscillator(),gain:n.createGain()};return t.osc.type=e,t.osc.start(),t.osc.connect(t.gain),t}var h=class{constructor(e,t="square"){this.audioContext=e;this.destination=null;this.filter=null;this.time=0;this.modulator=null;this.modulators=[];this.audioContext=e,this.carrier=m(this.audioContext,t),this.output=this.carrier.gain}withFilter(e,t,i){return this.filter=u(this.audioContext,e,t,i),this.carrier.gain.connect(this.filter),this.output=this.filter,this}withModulator(e="square",t,i,r="frequency"){let s=m(this.audioContext,e);s.osc.frequency.value=t,s.gain.gain.value=i;let a=null;if(!a)switch(r){case"frequency":a=this.carrier.osc.frequency;break;case"gain":a=this.carrier.gain.gain;break;case"filter":a=this.filter?.frequency;break;case"detune":a=this.carrier.osc.detune;break;case"last":this.modulators.length>0&&(a=this.modulators.slice(-1).pop().osc.frequency)}return a&&s.gain.connect(a),this.modulators.push(s),this}toDestination(e=null){return this.destination=e||this.audioContext.destination,this.output.connect(this.destination),this}play(e,t=1,i=0){let r=this.audioContext.currentTime+i,s=c(e);return this.carrier.osc.frequency.setValueAtTime(s,r),this.carrier.gain.gain.setValueAtTime(t,r),this.time=Math.max(i,this.time),this}rampToVolumeAtTime(e,t){let i=this.audioContext.currentTime+t;return this.carrier.gain.gain.linearRampToValueAtTime(e,i),this.time=Math.max(t,this.time),this}expRampToVolumeAtTime(e,t){let i=this.audioContext.currentTime+t;return this.carrier.gain.gain.exponentialRampToValueAtTime(e,i),this.time=Math.max(t,this.time),this}rampToNoteAtTime(e,t){let i=this.audioContext.currentTime+t,r=c(e);return this.carrier.osc.frequency.exponentialRampToValueAtTime(r,i),this.time=Math.max(t,this.time),this}setToNoteAtTime(e,t){let i=this.audioContext.currentTime+t,r=c(e);return this.carrier.osc.frequency.setValueAtTime(r,i),this.time=Math.max(t,this.time),this}setVolumeAtTime(e,t){let i=this.audioContext.currentTime+t;return this.carrier.gain.gain.setValueAtTime(e,i),this.time=Math.max(t,this.time),this}rampFilterFreqAtTime(e,t=0){this.time=Math.max(t,this.time);let i=this.audioContext.currentTime+t;return this.filter?.frequency.linearRampToValueAtTime(e,t),this}expRampFilterFreqAtTime(e,t=0){this.time=Math.max(t,this.time);let i=this.audioContext.currentTime+t;return this.filter?.frequency.exponentialRampToValueAtTime(e,t),this}wait(){return new Promise(e=>setTimeout(e,this.time*1e3))}dispose(){this.carrier.osc.stop(),this.carrier.osc.disconnect(),this.carrier.gain.disconnect(),this.filter?.disconnect();for(let e of this.modulators)e.osc.stop(),e.osc.disconnect(),e.gain.disconnect();this.modulators=[]}async waitDispose(){await this.wait(),this.dispose()}};var o=class o{constructor(e){this.audioContext=e;this.destination=null;this.filter=null;this.time=0;this.createNoiseBuffer(e),this.bufferSource=e.createBufferSource(),this.bufferSource.buffer=o.noiseBuffer,this.bufferSource.loop=!0,this.gain=e.createGain(),this.bufferSource.connect(this.gain),this.output=this.gain}play(){return this.bufferSource.start(),this}toDestination(e=null){return this.destination=e||this.audioContext.destination,this.output.connect(this.destination),this}withFilter(e,t,i){return this.filter=u(this.audioContext,e,t,i),this.gain.connect(this.filter),this.output=this.filter,this}setFilterFreqAtTime(e,t=0){this.time=Math.max(t,this.time);let i=this.audioContext.currentTime+t;return this.filter?.frequency.setValueAtTime(e,i),this}rampFilterFreqAtTime(e,t=0){this.time=Math.max(t,this.time);let i=this.audioContext.currentTime+t;return this.filter?.frequency.linearRampToValueAtTime(e,i),this}expRampFilterFreqAtTime(e,t=0){this.time=Math.max(t,this.time);let i=this.audioContext.currentTime+t;return this.filter?.frequency.exponentialRampToValueAtTime(e,i),this}rampToVolumeAtTime(e,t){let i=this.audioContext.currentTime+t;return this.gain.gain.linearRampToValueAtTime(e,i),this.time=Math.max(t,this.time),this}expRampToVolumeAtTime(e,t){let i=this.audioContext.currentTime+t;return this.gain.gain.exponentialRampToValueAtTime(e,i),this.time=Math.max(t,this.time),this}setVolumeAtTime(e,t){let i=this.audioContext.currentTime+t;return this.gain.gain.setValueAtTime(e,i),this.time=Math.max(t,this.time),this}createNoiseBuffer(e){if(o.noiseBuffer||o.bufferSize>0)return;let t=2*e.sampleRate,i=e.createBuffer(1,t,e.sampleRate),r=i.getChannelData(0);for(let s=0;s<t;s++)r[s]=Math.random()*2-1;o.bufferSize=t,o.noiseBuffer=i}wait(){return new Promise(e=>setTimeout(e,this.time*1e3))}dispose(){this.gain.disconnect(),this.bufferSource.stop(),this.filter?.disconnect()}async waitDispose(){await this.wait(),this.dispose()}};o.bufferSize=0,o.noiseBuffer=null;var l=o;export{h as Sound,l as WhiteNoise,u as createFilter,c as noteToFrequency,f as noteToMIDI};
